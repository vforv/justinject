{"version":3,"file":"/home/vladimir/Documents/ts-di/src/Container.ts","sources":["/home/vladimir/Documents/ts-di/src/Container.ts"],"names":[],"mappings":"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","sourcesContent":["import 'reflect-metadata';\nimport {  IType, MockingType } from './Model';\n\n/*eslint new-parens: \"error\"*/\nexport const Container = new class {\n    private service: Map<any, any> = new Map<any, IType<any>>();\n    private serviceType: Map<any, any> = new Map<any, IType<any>>();\n    private mocks: Map<any, any> = new Map<any, IType<any>>();\n    private hasMocks: boolean;\n\n    constructor() {\n        this.hasMocks = false;\n    }\n\n    public set(target: IType<any>, type?: string) {\n        this.setserviceType(target, type);\n    }\n\n    /**\n     * Resolove service with all deps\n     *\n     * @param target service to resolve\n     */\n    public resolve<T>(target: any): T {\n\n        // tokens are required dependencies, while injections are resolved tokens from the Container\n        const tokens: any = Reflect.getMetadata('design:paramtypes', target) || [];\n        const injections = tokens.map((token: any) => Container.resolve<any>(token));\n\n        if (this.hasMocks && this.isMockedClass(target)) {\n            const MockClass = this.getMock(target);\n            console.log(MockClass)\n            return this.resolveByserviceType<T>(MockClass, injections);\n        }\n\n        return this.resolveByserviceType<T>(target, injections);\n    }\n\n    /**\n     * Mock or replace service\n     *\n     * @param mocks all mocking services\n     */\n    public mock(mocks: MockingType) {\n        this.hasMocks = true;\n\n        mocks.map((target: any) => {\n            const serviceToMockName: string = target.dep.name.slice(0, -4);\n            const serviceToMockType: string = this.serviceType.get(serviceToMockName);\n\n            if (target.dep.name.slice(-4) !== 'Mock') {\n                throw Error('Class name must end with \"Mock\"');\n            }\n\n            if (!target.override && serviceToMockType === 'default') {\n                if (!(target.dep.prototype instanceof this.service.get(serviceToMockName))) {\n                    throw Error('\"Mock\" class must extends main instance, or use override tag');\n                }\n            }\n\n            this.setMocks(target, serviceToMockType);\n        });\n    }\n\n    /**\n     * Get mocking service\n     *\n     * @param target service which we want to mock\n     */\n    private getMock(target: any) {\n        return this.mocks.get(`${target.name}Mock`);\n    }\n\n    /**\n     * Check if target service, the service we want to mock\n     *\n     * @param target service which we want to mock\n     */\n    private isMockedClass(target: any) {\n        return this.mocks.has(`${target.name}Mock`);\n    }\n\n    /**\n     * This will reslove service, if service is sinleton\n     * we need just to return instance\n     *\n     * @param target service\n     * @param injections dependencies\n     */\n    private resolveByserviceType<T>(target: IType<T>, injections: any): T {\n        switch (this.serviceType.get(target.name)) {\n            case 'singleton': {\n                if (this.service.get(target.name) === null) {\n\n                    const inj = new target(...injections);\n                    this.service.set(target.name, inj);\n                    return inj;\n                }\n\n                return this.service.get(target.name);\n            }\n            case 'default': {\n                return new target(...injections);\n            }\n            default: {\n                return new target(...injections);\n            }\n        }\n    }\n\n    /**\n     * This will add mocking services to service property\n     *\n     * @param mockingService\n     * @param serviceToMockType\n     */\n    private setMocks(mockingService: any, serviceToMockType: string) {\n        this.serviceType.set(mockingService.dep.name, serviceToMockType);\n        this.mocks.set(mockingService.dep.name, mockingService.dep);\n\n        switch (serviceToMockType) {\n            case 'singleton': {\n                this.service.set(mockingService.dep.name, null);\n            }\n            case 'default': {\n                this.service.set(mockingService.dep.name, mockingService.dep);\n            }\n            default: {\n                this.service.set(mockingService.dep.name, mockingService.dep);\n            }\n        }\n    }\n\n    /**\n     * Add new service\n     *\n     * @param target new service to add\n     * @param type Type of service\n     */\n    private setserviceType(target: IType<any>, type?: string) {\n        this.service.set(target.name, target);\n\n        switch (type) {\n            case 'singleton': {\n                this.serviceType.set(target.name, 'singleton');\n                this.service.set(target.name, null);\n\n                return target;\n            }\n            case undefined: {\n                if (!this.serviceType.has(target.name)) {\n                    this.serviceType.set(target.name, 'default');\n                }\n\n                return target;\n            }\n            default: {\n                throw Error(`Please check ${target.name} service. Service type ${type} doesn't exists`);\n            }\n        }\n\n    }\n}();\n"]}